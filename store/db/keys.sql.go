// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: keys.sql

package db

import (
	"context"
)

const countKeysByCharacterSince = `-- name: CountKeysByCharacterSince :many
SELECT c.region, c.realm, c.name, COUNT(*) AS key_count
FROM completed_keys k
JOIN characters c ON c.id = k.character_id
WHERE k.completed_at > ?
GROUP BY c.region, c.realm, c.name
ORDER BY key_count DESC
`

type CountKeysByCharacterSinceRow struct {
	Region   string `json:"region"`
	Realm    string `json:"realm"`
	Name     string `json:"name"`
	KeyCount int64  `json:"key_count"`
}

func (q *Queries) CountKeysByCharacterSince(ctx context.Context, completedAt string) ([]CountKeysByCharacterSinceRow, error) {
	rows, err := q.db.QueryContext(ctx, countKeysByCharacterSince, completedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountKeysByCharacterSinceRow
	for rows.Next() {
		var i CountKeysByCharacterSinceRow
		if err := rows.Scan(
			&i.Region,
			&i.Realm,
			&i.Name,
			&i.KeyCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteCharacter = `-- name: DeleteCharacter :exec
DELETE FROM characters WHERE id = ?
`

func (q *Queries) DeleteCharacter(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteCharacter, id)
	return err
}

const deleteCompletedKeysByCharacter = `-- name: DeleteCompletedKeysByCharacter :exec
DELETE FROM completed_keys WHERE character_id = ?
`

func (q *Queries) DeleteCompletedKeysByCharacter(ctx context.Context, characterID int64) error {
	_, err := q.db.ExecContext(ctx, deleteCompletedKeysByCharacter, characterID)
	return err
}

const deleteWarcraftLogsLinksByCharacter = `-- name: DeleteWarcraftLogsLinksByCharacter :exec
DELETE FROM warcraftlogs_links
WHERE key_id IN (
  SELECT k.key_id FROM completed_keys k
  JOIN characters c ON c.id = k.character_id
  WHERE c.id = ?
)
`

func (q *Queries) DeleteWarcraftLogsLinksByCharacter(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteWarcraftLogsLinksByCharacter, id)
	return err
}

const getCharacter = `-- name: GetCharacter :one
SELECT id, region, realm, name FROM characters
WHERE LOWER(name) = LOWER(?) AND LOWER(realm) = LOWER(?) AND LOWER(region) = LOWER(?)
`

type GetCharacterParams struct {
	LOWER   string `json:"LOWER"`
	LOWER_2 string `json:"LOWER_2"`
	LOWER_3 string `json:"LOWER_3"`
}

func (q *Queries) GetCharacter(ctx context.Context, arg GetCharacterParams) (Character, error) {
	row := q.db.QueryRowContext(ctx, getCharacter, arg.LOWER, arg.LOWER_2, arg.LOWER_3)
	var i Character
	err := row.Scan(
		&i.ID,
		&i.Region,
		&i.Realm,
		&i.Name,
	)
	return i, err
}

const getCharacterID = `-- name: GetCharacterID :one
SELECT id FROM characters
WHERE LOWER(name) = LOWER(?) AND LOWER(realm) = LOWER(?) AND LOWER(region) = LOWER(?)
`

type GetCharacterIDParams struct {
	LOWER   string `json:"LOWER"`
	LOWER_2 string `json:"LOWER_2"`
	LOWER_3 string `json:"LOWER_3"`
}

func (q *Queries) GetCharacterID(ctx context.Context, arg GetCharacterIDParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getCharacterID, arg.LOWER, arg.LOWER_2, arg.LOWER_3)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertCompletedKey = `-- name: InsertCompletedKey :exec
INSERT INTO completed_keys(
  key_id, character_id, dungeon, key_lvl, run_time_ms, par_time_ms, completed_at, source
) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(key_id) DO UPDATE SET
  dungeon = excluded.dungeon,
  key_lvl = excluded.key_lvl,
  run_time_ms = excluded.run_time_ms,
  par_time_ms = excluded.par_time_ms,
  completed_at = excluded.completed_at,
  source = excluded.source
`

type InsertCompletedKeyParams struct {
	KeyID       int64  `json:"key_id"`
	CharacterID int64  `json:"character_id"`
	Dungeon     string `json:"dungeon"`
	KeyLvl      int64  `json:"key_lvl"`
	RunTimeMs   int64  `json:"run_time_ms"`
	ParTimeMs   int64  `json:"par_time_ms"`
	CompletedAt string `json:"completed_at"`
	Source      string `json:"source"`
}

func (q *Queries) InsertCompletedKey(ctx context.Context, arg InsertCompletedKeyParams) error {
	_, err := q.db.ExecContext(ctx, insertCompletedKey,
		arg.KeyID,
		arg.CharacterID,
		arg.Dungeon,
		arg.KeyLvl,
		arg.RunTimeMs,
		arg.ParTimeMs,
		arg.CompletedAt,
		arg.Source,
	)
	return err
}

const listAllKeysWithCharacters = `-- name: ListAllKeysWithCharacters :many
SELECT k.key_id, c.id as character_id, c.region, c.realm, c.name AS character,
k.dungeon, k.key_lvl, k.run_time_ms, k.par_time_ms, k.completed_at, k.source
FROM completed_keys k
JOIN characters c ON c.id = k.character_id
ORDER BY k.completed_at DESC
`

type ListAllKeysWithCharactersRow struct {
	KeyID       int64  `json:"key_id"`
	CharacterID int64  `json:"character_id"`
	Region      string `json:"region"`
	Realm       string `json:"realm"`
	Character   string `json:"character"`
	Dungeon     string `json:"dungeon"`
	KeyLvl      int64  `json:"key_lvl"`
	RunTimeMs   int64  `json:"run_time_ms"`
	ParTimeMs   int64  `json:"par_time_ms"`
	CompletedAt string `json:"completed_at"`
	Source      string `json:"source"`
}

func (q *Queries) ListAllKeysWithCharacters(ctx context.Context) ([]ListAllKeysWithCharactersRow, error) {
	rows, err := q.db.QueryContext(ctx, listAllKeysWithCharacters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllKeysWithCharactersRow
	for rows.Next() {
		var i ListAllKeysWithCharactersRow
		if err := rows.Scan(
			&i.KeyID,
			&i.CharacterID,
			&i.Region,
			&i.Realm,
			&i.Character,
			&i.Dungeon,
			&i.KeyLvl,
			&i.RunTimeMs,
			&i.ParTimeMs,
			&i.CompletedAt,
			&i.Source,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCharacters = `-- name: ListCharacters :many
SELECT region, realm, name FROM characters ORDER BY region, realm, name
`

type ListCharactersRow struct {
	Region string `json:"region"`
	Realm  string `json:"realm"`
	Name   string `json:"name"`
}

func (q *Queries) ListCharacters(ctx context.Context) ([]ListCharactersRow, error) {
	rows, err := q.db.QueryContext(ctx, listCharacters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCharactersRow
	for rows.Next() {
		var i ListCharactersRow
		if err := rows.Scan(&i.Region, &i.Realm, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listKeysByCharacterSince = `-- name: ListKeysByCharacterSince :many
SELECT k.key_id, c.region, c.realm, c.name AS character, k.dungeon, k.key_lvl,
k.run_time_ms, k.par_time_ms, k.completed_at, k.source
FROM completed_keys k
JOIN characters c ON c.id = k.character_id
WHERE LOWER(c.name) = LOWER(?) AND k.completed_at > ?
ORDER BY k.completed_at DESC
`

type ListKeysByCharacterSinceParams struct {
	LOWER       string `json:"LOWER"`
	CompletedAt string `json:"completed_at"`
}

type ListKeysByCharacterSinceRow struct {
	KeyID       int64  `json:"key_id"`
	Region      string `json:"region"`
	Realm       string `json:"realm"`
	Character   string `json:"character"`
	Dungeon     string `json:"dungeon"`
	KeyLvl      int64  `json:"key_lvl"`
	RunTimeMs   int64  `json:"run_time_ms"`
	ParTimeMs   int64  `json:"par_time_ms"`
	CompletedAt string `json:"completed_at"`
	Source      string `json:"source"`
}

func (q *Queries) ListKeysByCharacterSince(ctx context.Context, arg ListKeysByCharacterSinceParams) ([]ListKeysByCharacterSinceRow, error) {
	rows, err := q.db.QueryContext(ctx, listKeysByCharacterSince, arg.LOWER, arg.CompletedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListKeysByCharacterSinceRow
	for rows.Next() {
		var i ListKeysByCharacterSinceRow
		if err := rows.Scan(
			&i.KeyID,
			&i.Region,
			&i.Realm,
			&i.Character,
			&i.Dungeon,
			&i.KeyLvl,
			&i.RunTimeMs,
			&i.ParTimeMs,
			&i.CompletedAt,
			&i.Source,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listKeysSince = `-- name: ListKeysSince :many
SELECT k.key_id, c.region, c.realm, c.name AS character, k.dungeon, k.key_lvl,
  k.run_time_ms, k.par_time_ms, k.completed_at, k.source
FROM completed_keys k
JOIN characters c ON c.id = k.character_id
WHERE k.completed_at > ?
ORDER BY k.completed_at DESC
`

type ListKeysSinceRow struct {
	KeyID       int64  `json:"key_id"`
	Region      string `json:"region"`
	Realm       string `json:"realm"`
	Character   string `json:"character"`
	Dungeon     string `json:"dungeon"`
	KeyLvl      int64  `json:"key_lvl"`
	RunTimeMs   int64  `json:"run_time_ms"`
	ParTimeMs   int64  `json:"par_time_ms"`
	CompletedAt string `json:"completed_at"`
	Source      string `json:"source"`
}

func (q *Queries) ListKeysSince(ctx context.Context, completedAt string) ([]ListKeysSinceRow, error) {
	rows, err := q.db.QueryContext(ctx, listKeysSince, completedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListKeysSinceRow
	for rows.Next() {
		var i ListKeysSinceRow
		if err := rows.Scan(
			&i.KeyID,
			&i.Region,
			&i.Realm,
			&i.Character,
			&i.Dungeon,
			&i.KeyLvl,
			&i.RunTimeMs,
			&i.ParTimeMs,
			&i.CompletedAt,
			&i.Source,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertCharacter = `-- name: UpsertCharacter :one
INSERT INTO characters(region, realm, name)
VALUES (?, ?, ?)
ON CONFLICT(region, realm, name) DO UPDATE SET name=excluded.name
RETURNING id
`

type UpsertCharacterParams struct {
	Region string `json:"region"`
	Realm  string `json:"realm"`
	Name   string `json:"name"`
}

func (q *Queries) UpsertCharacter(ctx context.Context, arg UpsertCharacterParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, upsertCharacter, arg.Region, arg.Realm, arg.Name)
	var id int64
	err := row.Scan(&id)
	return id, err
}
